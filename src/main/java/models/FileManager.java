package models;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import java.io.File;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * FileManager is used to ensure that objects are created with corresponding files. It achieves this by creating new
 * objects that require corresponding files via {@link CallbackFileBuilder}.
 * @param <T> The objects to be managed
 * @author Tait & Alex
 */
public abstract class FileManager<T> {
    /**
     * An observable list of the items contained by FileManager
     */
    protected ObservableList<T> items;
    /**
     * A map that is maintained alongside {@code items} that contains file-mappings of each item
     */
    protected Map<T, File> files;

    /**
     * Default constructor instantiates items and files with synchronised Collections
     */
    public FileManager() {
        items = FXCollections.synchronizedObservableList(FXCollections.observableArrayList());
        files = Collections.synchronizedMap(new HashMap<>());
    }

    /**
     * Returns an unmodifiable observable list of items
     * @return An unmodifiable observable list of items
     */
    public ObservableList<T> getItems() {
        return FXCollections.unmodifiableObservableList(items);
    }

    /**
     * Return the {@link File} for the given item
     * @param item The item whose File we are requesting
     * @return The file for the given item
     */
    public File getFile(T item) {
        return files.get(item);
    }

    /**
     * Return an {@link CallbackFileBuilder}
     * @return
     */
    public abstract CallbackFileBuilder<T> getBuilder();

    /**
     * Creates a new object using {@link CallbackFileBuilder} and adds this new object to {@code items}
     * @param builder The builder to create a new object from
     */
    public void create(CallbackFileBuilder<T> builder) {
        builder.build(this);
    }

    /**
     * Save the item generated by {@link CallbackFileBuilder}
     * @param item
     * @param file
     */
    public void save(T item, File file) {
        files.put(item, file);
        System.out.println(item);
        items.add(item);
    }

    /**
     * Removes a specified object from {@code items} and its files
     * @param item The object to be deleted
     */
    public void delete(T item) {
        recursiveDelete(getFile(item));
        items.remove(item);
        files.remove(item);
    }

    /**
     * Helper method to recursively delete a directory
     * @param directory The directory to delete
     * @return True if the deletion succeeded
     */
    protected boolean recursiveDelete(File directory) {
        if (directory.isDirectory()) {
            File[] children = directory.listFiles();
            if (children != null) {
                for (File child : children) {
                    boolean status = recursiveDelete(child);
                    if (!status) {
                        return false;
                    }
                }
            }
        }
        return directory.delete();
    }
}
